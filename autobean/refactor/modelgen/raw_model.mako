<%
import collections
import stringcase
from autobean.refactor.modelgen.field_descriptor import FieldCardinality
from autobean.refactor.meta_models.base import Floating

typing_imports = {'TypeVar', 'Type', 'final'}
if any(field.cardinality == FieldCardinality.OPTIONAL for field in fields):
    typing_imports.add('Optional')
model_imports = collections.defaultdict(set)
model_imports_type_check_only = collections.defaultdict(set)
model_imports['punctuation'].add('Whitespace')
for field in fields:
    if field.define_as: continue
    for model_type in field.model_types:
        if field.circular_dep:
            model_imports_type_check_only[model_type.module].add(model_type.name)
            typing_imports.add('TYPE_CHECKING')
        else:
            model_imports[model_type.module].add(model_type.name)
%>\
# DO NOT EDIT
# This file is automatically generated by autobean.refactor.modelgen.

from typing import ${', '.join(sorted(typing_imports))}
from .. import base
from .. import internal
% for name, imports in sorted(model_imports.items()):
from ..${name} import ${', '.join(sorted(imports))}
% endfor
% if model_imports_type_check_only:
if TYPE_CHECKING:
% for name, imports in sorted(model_imports_type_check_only.items()):
  from ..${name} import ${', '.join(sorted(imports))}
% endfor
% endif

% for field in fields:
% if field.type_alias is not None:
${field.type_alias} = ${field.inner_type_original}
% endif
% endfor
_Self = TypeVar('_Self', bound='${model_name}')
% for field in fields:
% if field.define_as:


@internal.token_model
% if field.define_default is not None:
class ${field.define_as}(internal.SimpleDefaultRawTokenModel):
    RULE = '${next(iter(field.model_types)).rule}'
    DEFAULT = '${field.define_default}'
% else:
class ${field.define_as}(internal.SimpleRawTokenModel):
    RULE = '${next(iter(field.model_types)).rule}'
% endif
% endif
% endfor


@internal.tree_model
class ${model_name}(base.RawTreeModel):
    RULE = '${stringcase.snakecase(model_name)}'

% for field in fields:
% if field.cardinality == FieldCardinality.REQUIRED:
    _${field.name} = internal.required_field[${field.inner_type}]()
% elif field.cardinality == FieldCardinality.OPTIONAL:
    _${field.name} = internal.optional_field[${field.inner_type}](floating=internal.Floating.${field.floating.name}, separators=(Whitespace.from_default(),))
% else:
<% assert False %>\
% endif
% endfor

% for field in fields:
<% if not field.is_public: continue %>\
% if field.cardinality == FieldCardinality.REQUIRED:
    raw_${field.name} = internal.required_node_property(_${field.name})
% elif field.cardinality == FieldCardinality.OPTIONAL:
    raw_${field.name} = internal.optional_node_property(_${field.name})
% else:
<% assert False %>\
% endif
% endfor

    @final
    def __init__(
            self,
            token_store: base.TokenStore,
% for field in fields:
            ${field.name}: ${field.private_type},
% endfor
    ):
        super().__init__(token_store)
% for field in fields:
        self._${field.name} = ${field.name}
% endfor

    @property
    def first_token(self) -> base.RawTokenModel:
        return self._${fields[0].name}.first_token

    @property
    def last_token(self) -> base.RawTokenModel:
        return self._${fields[-1].name}.last_token

    def clone(self: _Self, token_store: base.TokenStore, token_transformer: base.TokenTransformer) -> _Self:
        return type(self)(
            token_store,
% for field in fields:
            self._${field.name}.clone(token_store, token_transformer),
% endfor
        )
    
    def _reattach(self, token_store: base.TokenStore, token_transformer: base.TokenTransformer) -> None:
        self._token_store = token_store
% for field in fields:
        self._${field.name} = self._${field.name}.reattach(token_store, token_transformer)
% endfor

    def _eq(self, other: base.RawTreeModel) -> bool:
        return (
            isinstance(other, ${model_name})
% for field in fields:
            and self._${field.name} == other._${field.name}
% endfor
        )

    @classmethod
    def from_children(
            cls: Type[_Self],
% for field in fields:
<% if not field.is_public: continue %>\
            ${field.name}: ${field.public_type},
% endfor
    ) -> _Self:
% for field in fields:
% if not field.is_public:
        ${field.name} = ${field.inner_type}.from_default()
% elif field.cardinality == FieldCardinality.OPTIONAL:
<%
# mypy isn't good at inferring union type
type_fix = f'[{field.type_alias}]' if field.type_alias is not None else ''
%>\
        maybe_${field.name} = internal.Maybe${field.floating.name[0]}${type_fix}.from_children(${field.name}, separators=cls._${field.name}.separators)
% endif
% endfor
<%
skip_space = True
args = []
%>\
        tokens = [
% for field in fields:
% if not skip_space and field.floating != Floating.LEFT:
            Whitespace.from_default(),
% endif
% if field.cardinality == FieldCardinality.REQUIRED:
            *${field.name}.detach(),
<%
skip_space = False
args.append(field.name)
%>\
% elif field.cardinality == FieldCardinality.OPTIONAL:
            *maybe_${field.name}.detach(),
<%
skip_space = field.floating == Floating.RIGHT
args.append(f'maybe_{field.name}')
%>\
% else:
<% assert False %>\
% endif
% endfor
        ]
        token_store = base.TokenStore.from_tokens(tokens)
% for arg in args:
        ${arg}.reattach(token_store)
% endfor
        return cls(token_store, ${', '.join(args)})
