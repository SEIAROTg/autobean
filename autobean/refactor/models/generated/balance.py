# DO NOT EDIT
# This file is automatically generated by autobean.refactor.modelgen.

import datetime
import decimal
from typing import Optional, Type, TypeVar, final
from .. import base, internal
from ..account import Account
from ..currency import Currency
from ..date import Date
from ..number_expr import NumberExpr
from ..punctuation import Eol, Whitespace
from ..tolerance import Tolerance

_Self = TypeVar('_Self', bound='Balance')


@internal.token_model
class BalanceLabel(internal.SimpleDefaultRawTokenModel):
    RULE = 'BALANCE'
    DEFAULT = 'balance'


@internal.tree_model
class Balance(base.RawTreeModel):
    RULE = 'balance'

    _date = internal.required_field[Date]()
    _label = internal.required_field[BalanceLabel]()
    _account = internal.required_field[Account]()
    _number = internal.required_field[NumberExpr]()
    _tolerance = internal.optional_field[Tolerance](separators=(Whitespace.from_default(),))
    _currency = internal.required_field[Currency]()
    _eol = internal.required_field[Eol]()

    raw_date = internal.required_node_property(_date)
    raw_account = internal.required_node_property(_account)
    raw_number = internal.required_node_property(_number)
    raw_tolerance = internal.optional_node_property(_tolerance)
    raw_currency = internal.required_node_property(_currency)

    date = internal.required_date_property(raw_date)
    account = internal.required_string_property(raw_account)
    number = internal.required_decimal_property(raw_number)
    tolerance = internal.optional_decimal_property(raw_tolerance, Tolerance)
    currency = internal.required_string_property(raw_currency)

    @final
    def __init__(
            self,
            token_store: base.TokenStore,
            date: Date,
            label: BalanceLabel,
            account: Account,
            number: NumberExpr,
            tolerance: internal.Maybe[Tolerance],
            currency: Currency,
            eol: Eol,
    ):
        super().__init__(token_store)
        self._date = date
        self._label = label
        self._account = account
        self._number = number
        self._tolerance = tolerance
        self._currency = currency
        self._eol = eol

    @property
    def first_token(self) -> base.RawTokenModel:
        return self._date.first_token

    @property
    def last_token(self) -> base.RawTokenModel:
        return self._eol.last_token

    def clone(self: _Self, token_store: base.TokenStore, token_transformer: base.TokenTransformer) -> _Self:
        return type(self)(
            token_store,
            self._date.clone(token_store, token_transformer),
            self._label.clone(token_store, token_transformer),
            self._account.clone(token_store, token_transformer),
            self._number.clone(token_store, token_transformer),
            self._tolerance.clone(token_store, token_transformer),
            self._currency.clone(token_store, token_transformer),
            self._eol.clone(token_store, token_transformer),
        )

    def _reattach(self, token_store: base.TokenStore, token_transformer: base.TokenTransformer) -> None:
        self._token_store = token_store
        self._date = self._date.reattach(token_store, token_transformer)
        self._label = self._label.reattach(token_store, token_transformer)
        self._account = self._account.reattach(token_store, token_transformer)
        self._number = self._number.reattach(token_store, token_transformer)
        self._tolerance = self._tolerance.reattach(token_store, token_transformer)
        self._currency = self._currency.reattach(token_store, token_transformer)
        self._eol = self._eol.reattach(token_store, token_transformer)

    def _eq(self, other: base.RawTreeModel) -> bool:
        return (
            isinstance(other, Balance)
            and self._date == other._date
            and self._label == other._label
            and self._account == other._account
            and self._number == other._number
            and self._tolerance == other._tolerance
            and self._currency == other._currency
            and self._eol == other._eol
        )

    @classmethod
    def from_children(
            cls: Type[_Self],
            date: Date,
            account: Account,
            number: NumberExpr,
            tolerance: Optional[Tolerance],
            currency: Currency,
    ) -> _Self:
        label = BalanceLabel.from_default()
        maybe_tolerance = internal.MaybeL.from_children(tolerance, separators=cls._tolerance.separators)
        eol = Eol.from_default()
        tokens = [
            *date.detach(),
            Whitespace.from_default(),
            *label.detach(),
            Whitespace.from_default(),
            *account.detach(),
            Whitespace.from_default(),
            *number.detach(),
            *maybe_tolerance.detach(),
            Whitespace.from_default(),
            *currency.detach(),
            *eol.detach(),
        ]
        token_store = base.TokenStore.from_tokens(tokens)
        date.reattach(token_store)
        label.reattach(token_store)
        account.reattach(token_store)
        number.reattach(token_store)
        maybe_tolerance.reattach(token_store)
        currency.reattach(token_store)
        eol.reattach(token_store)
        return cls(token_store, date, label, account, number, maybe_tolerance, currency, eol)

    @classmethod
    def from_value(
            cls: Type[_Self],
            date: datetime.date,
            account: str,
            number: decimal.Decimal,
            tolerance: Optional[decimal.Decimal],
            currency: str,
    ) -> _Self:
        return cls.from_children(
            Date.from_value(date),
            Account.from_value(account),
            NumberExpr.from_value(number),
            Tolerance.from_value(tolerance) if tolerance is not None else None,
            Currency.from_value(currency),
        )
