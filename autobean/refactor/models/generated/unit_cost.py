# DO NOT EDIT
# This file is automatically generated by autobean.refactor.modelgen.

from typing import Iterable, Type, TypeVar, final
from .. import base, internal
from ..cost_component import CostComponent
from ..punctuation import Comma
from ..spacing import Whitespace

_Self = TypeVar('_Self', bound='UnitCost')


@internal.token_model
class LeftBrace(internal.SimpleDefaultRawTokenModel):
    RULE = 'LEFT_BRACE'
    DEFAULT = '{'


@internal.token_model
class RightBrace(internal.SimpleDefaultRawTokenModel):
    RULE = 'RIGHT_BRACE'
    DEFAULT = '}'


@internal.tree_model
class UnitCost(base.RawTreeModel, internal.SpacingAccessorsMixin):
    RULE = 'unit_cost'

    _left_brace = internal.required_field[LeftBrace]()
    _components = internal.repeated_field[CostComponent](separators=(Comma.from_default(), Whitespace.from_default()), separators_before=())
    _right_brace = internal.required_field[RightBrace]()

    raw_components = internal.repeated_node_property(_components)

    @final
    def __init__(
            self,
            token_store: base.TokenStore,
            left_brace: LeftBrace,
            repeated_components: internal.Repeated[CostComponent],
            right_brace: RightBrace,
    ):
        super().__init__(token_store)
        self._left_brace = left_brace
        self._components = repeated_components
        self._right_brace = right_brace

    @property
    def first_token(self) -> base.RawTokenModel:
        return self._left_brace.first_token

    @property
    def last_token(self) -> base.RawTokenModel:
        return self._right_brace.last_token

    def clone(self: _Self, token_store: base.TokenStore, token_transformer: base.TokenTransformer) -> _Self:
        return type(self)(
            token_store,
            type(self)._left_brace.clone(self._left_brace, token_store, token_transformer),
            type(self)._components.clone(self._components, token_store, token_transformer),
            type(self)._right_brace.clone(self._right_brace, token_store, token_transformer),
        )

    def _reattach(self, token_store: base.TokenStore, token_transformer: base.TokenTransformer) -> None:
        self._token_store = token_store
        self._left_brace = type(self)._left_brace.reattach(self._left_brace, token_store, token_transformer)
        self._components = type(self)._components.reattach(self._components, token_store, token_transformer)
        self._right_brace = type(self)._right_brace.reattach(self._right_brace, token_store, token_transformer)

    def _eq(self, other: base.RawTreeModel) -> bool:
        return (
            isinstance(other, UnitCost)
            and self._left_brace == other._left_brace
            and self._components == other._components
            and self._right_brace == other._right_brace
        )

    @classmethod
    def from_children(
            cls: Type[_Self],
            components: Iterable[CostComponent],
    ) -> _Self:
        left_brace = LeftBrace.from_default()
        repeated_components = cls._components.create_repeated(components)
        right_brace = RightBrace.from_default()
        tokens = [
            *left_brace.detach(),
            *cls._components.detach_with_separators(repeated_components),
            *right_brace.detach(),
        ]
        token_store = base.TokenStore.from_tokens(tokens)
        cls._left_brace.reattach(left_brace, token_store)
        cls._components.reattach(repeated_components, token_store)
        cls._right_brace.reattach(right_brace, token_store)
        return cls(token_store, left_brace, repeated_components, right_brace)

    def auto_claim_comments(self) -> None:
        self.raw_components.auto_claim_comments()
