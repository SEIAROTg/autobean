# DO NOT EDIT
# This file is automatically generated by autobean.refactor.modelgen.

from typing import Iterable, Type, TypeVar, final
from .. import base, internal
from ..cost_component import CostComponent
from ..punctuation import Comma
from ..spacing import Whitespace

_Self = TypeVar('_Self', bound='TotalCost')


@internal.token_model
class DblLeftBrace(internal.SimpleDefaultRawTokenModel):
    RULE = 'DBL_LEFT_BRACE'
    DEFAULT = '{{'


@internal.token_model
class DblRightBrace(internal.SimpleDefaultRawTokenModel):
    RULE = 'DBL_RIGHT_BRACE'
    DEFAULT = '}}'


@internal.tree_model
class TotalCost(base.RawTreeModel, internal.SpacingAccessorsMixin):
    RULE = 'total_cost'

    _dbl_left_brace = internal.required_field[DblLeftBrace]()
    _components = internal.repeated_field[CostComponent](separators=(Comma.from_default(), Whitespace.from_default()), separators_before=())
    _dbl_right_brace = internal.required_field[DblRightBrace]()

    raw_components = internal.repeated_node_property(_components)

    @final
    def __init__(
            self,
            token_store: base.TokenStore,
            dbl_left_brace: DblLeftBrace,
            repeated_components: internal.Repeated[CostComponent],
            dbl_right_brace: DblRightBrace,
    ):
        super().__init__(token_store)
        self._dbl_left_brace = dbl_left_brace
        self._components = repeated_components
        self._dbl_right_brace = dbl_right_brace

    @property
    def first_token(self) -> base.RawTokenModel:
        return self._dbl_left_brace.first_token

    @property
    def last_token(self) -> base.RawTokenModel:
        return self._dbl_right_brace.last_token

    def clone(self: _Self, token_store: base.TokenStore, token_transformer: base.TokenTransformer) -> _Self:
        return type(self)(
            token_store,
            type(self)._dbl_left_brace.clone(self._dbl_left_brace, token_store, token_transformer),
            type(self)._components.clone(self._components, token_store, token_transformer),
            type(self)._dbl_right_brace.clone(self._dbl_right_brace, token_store, token_transformer),
        )

    def _reattach(self, token_store: base.TokenStore, token_transformer: base.TokenTransformer) -> None:
        self._token_store = token_store
        self._dbl_left_brace = type(self)._dbl_left_brace.reattach(self._dbl_left_brace, token_store, token_transformer)
        self._components = type(self)._components.reattach(self._components, token_store, token_transformer)
        self._dbl_right_brace = type(self)._dbl_right_brace.reattach(self._dbl_right_brace, token_store, token_transformer)

    def _eq(self, other: base.RawTreeModel) -> bool:
        return (
            isinstance(other, TotalCost)
            and self._dbl_left_brace == other._dbl_left_brace
            and self._components == other._components
            and self._dbl_right_brace == other._dbl_right_brace
        )

    @classmethod
    def from_children(
            cls: Type[_Self],
            components: Iterable[CostComponent],
    ) -> _Self:
        dbl_left_brace = DblLeftBrace.from_default()
        repeated_components = cls._components.create_repeated(components)
        dbl_right_brace = DblRightBrace.from_default()
        tokens = [
            *dbl_left_brace.detach(),
            *cls._components.detach_with_separators(repeated_components),
            *dbl_right_brace.detach(),
        ]
        token_store = base.TokenStore.from_tokens(tokens)
        cls._dbl_left_brace.reattach(dbl_left_brace, token_store)
        cls._components.reattach(repeated_components, token_store)
        cls._dbl_right_brace.reattach(dbl_right_brace, token_store)
        return cls(token_store, dbl_left_brace, repeated_components, dbl_right_brace)

    def auto_claim_comments(self) -> None:
        self.raw_components.auto_claim_comments()
